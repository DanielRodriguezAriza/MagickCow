# region Blender Operator classes for JSON Exporter.

# This class is the exporter operator for all types of files that can be generated by MagickCow.
# NOTE : In the past, we used to have a different export operator for each type of object. Now, they all contain their code within this operator, since the export type is selected on the scene panel.
# We still separate the logic in different methods tho, that way things are easier to deal with, but we only have 1 single exporter operator class rather than multiple classes.
class MagickCowExportOperator(bpy.types.Operator, bpy_extras.io_utils.ExportHelper):
    
    # region Blender specific configuration:
    
    bl_idname = "object.magickcow_export"
    bl_label = "MagickCow Export MagickaPUP JSON"
    bl_description = "Export Scene to MagickaPUP JSON file (.json)"

    # endregion
    
    # region Exporter Panel Config

    filename_ext = ".json"
    filter_glob : bpy.props.StringProperty(default = "*.json", options = {'HIDDEN'})
    
    # region Deprecated

    # Discarded code where the properties used to depend on the export operator itself. Now they are global to the scene config / data instead.
    # region Deprecated Code
    # mcow_setting_export_path : bpy.props.StringProperty(
    #     name = "Config Path",
    #     description = "Select the path in which the exporter will look for the base folder. This folder contains JSON files which correspond to effects (materials) that will be applied to the surfaces that have a material with the name of the corresponding effect file to be used.",
    #     default = "C:\\"
    # )
    # 
    # mcow_setting_export_animation_data : bpy.props.BoolProperty(
    #     name = "Export Animation Data",
    #     description = "Determines whether the animation side of the scene will be exported or not.\n - If True : The animated level parts will be exported, including all of the child objects and animation data.\n - If False : The animated level parts will be completely ignored and not exported. All children components, including geometry, lights, and any other type of object, that is attached to animated level parts, will also be ignored.\n - Note : The animated level parts root still needs to be present for the exporter to properly generate the level data.",
    #     default = False
    # )
    # 
    # mcow_setting_export_pretty : bpy.props.BoolProperty(
    #     name = "Pretty JSON Format",
    #     description = "The JSON file will be exported with indentation and newlines for easier reading. Slows down export times due to the extra processing required. It also increases the resulting file size due to the extra characters required for newlines and indentation. Recommended to only enable this setting if debugging the output of the generated JSON file is absolutely necessary, specially when working with large maps with high level of detail.",
    #     default = False
    # )
    # 
    # mcow_setting_export_indent : bpy.props.IntProperty(
    #     name = "Indent Depth",
    #     description = "Number of space characters to use in the output JSON file for indentation. This setting is ignored if pretty JSON formatting is disabled.",
    #     default = 2,
    #     min = 1,
    #     max = 256 # Who the fuck is going to need this tho??? Anyone who is dicking around and wants to find out the limit, I guess.
    # )

    # endregion

    # endregion

    # endregion

    # region JSON aux methods

    # NOTE : We use json.dumps to make a string rather than json.dump to dump directly into a file because json.dump is absurdly slow, but json.dumps and then writing the generated string into a file is way faster...
    # Maybe some weird python buffering shenanigans? Oh how I miss fprintf...
    def json_dump_str(self, context, obj_dict):

        is_pretty = context.scene.mcow_scene_json_pretty
        selected_indent = context.scene.mcow_scene_json_indent if context.scene.mcow_scene_json_char == "SPACE" else "\t"

        if is_pretty:
            return json.dumps(obj_dict, indent = selected_indent, separators = (",", ":"), check_circular = False)
        return json.dumps(obj_dict, indent = None, separators = (",", ":"), check_circular = False)

    # endregion

    # region Main Exporter Code

    def execute(self, context):
        return self.export_data(context)
    
    def export_data(self, context):
        scene = context.scene
        export_mode = scene.mcow_scene_mode
        ans = {} # This is an empty object, but the type of answer object we expect from the export functions is a Blender message, something like {"FINISHED"} or {"CANCELLED"} or whatever.
        
        # Save (backup) the scene state as it was before exporting the scene
        # NOTE : The bpy.data properties used to check if the file is saved are the following: 
        # - is_saved : checks if the scene is saved into a file
        # - is_dirty : checks if the latest state in memory has been saved to the file on disk
        if (not bpy.data.is_saved) or bpy.data.is_dirty:
            self.report({"ERROR"}, "Cannot export the scene if it has not been saved!")
            return {"CANCELLED"}
        
        # Perform export process
        try:
            if export_mode == "MAP":
                ans = self.export_data_map(context)
            elif export_mode == "PHYSICS_ENTITY":
                ans = self.export_data_physics_entity(context)
            else:
                ans = self.export_data_none(context)
        except MagickCowException as e:
            self.report({"ERROR"}, f"Failed to export data: {e}")
            return {"CANCELLED"}
        finally:
            # Load (restore) the scene state as it was before exporting the scene
            # This undoes the scene rotations, modifier applications, etc... basically performs and undo that undoes all destructive changes that were performed when exporting the scene
            # This happens within the finally block so that it always takes place even if an error were to happen during export, which prevents the mcow exporter from breaking the scene during export.
            bpy.ops.wm.open_mainfile(filepath = bpy.data.filepath)

        return ans

    def export_data_none(self, context):
        self.report({"ERROR"}, "Cannot export scene data unless a scene export mode is selected!")
        return {"CANCELLED"}

    def export_data_map(self, context):
        return self.export_data_func(context, "Map", MCow_Data_Pipeline_Map())

    def export_data_physics_entity(self, context):
        return self.export_data_func(context, "Physics Entity", MCow_Data_Pipeline_PhysicsEntity())
    
    def write_to_file(self, contents):
        try:
            with open(self.filepath, 'w') as outfile:
                outfile.write(contents)
            self.report({"INFO"}, f"Successfully exported data to file \"{self.filepath}\"")
            return {"FINISHED"}
        except Exception as e:
            self.report({"ERROR"}, f"Failed to export data: {e}")
            return {"CANCELLED"}

    def export_data_func(self, context, name, generator):
        self.report({"INFO"}, f"Exporting to MagickaPUP .json {name} file...")

        xnb_dict = generator.process_scene_data()
        json_str = self.json_dump_str(context, xnb_dict)

        return self.write_to_file(json_str)

    # endregion

# endregion

# region Blender Export Panel functions, Register and Unregister functions

def menu_func_export(self, context):
    self.layout.operator(MagickCowExportOperator.bl_idname, text = "MagickaPUP JSON (.json)")

def register_exporters():
    bpy.utils.register_class(MagickCowExportOperator)
    bpy.types.TOPBAR_MT_file_export.append(menu_func_export)

def unregister_exporters():
    bpy.utils.unregister_class(MagickCowExportOperator)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func_export)

# endregion
